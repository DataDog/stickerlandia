# mise configuration for stickerlandia

experimental_monorepo_root = true

[settings]
experimental = true
auto_install = true

[tools]
# Used by CDK infrastructure and web-frontend/web-backend
node = "22"

# Used by sticker-award
go = "1.25"

# Used by sticker-catalogue
java = "temurin-21"

# Used by sticker-catalogue
maven = "3.9"

# Used by user-management
dotnet = "10"

# =============================================================================
# env: Environment setup
# =============================================================================

[env]
_.file = { path = ".env", optional = true }

[tasks."env:setup"]
description = "Create .env file with required configuration"
hide = true
run = """
if [ -f .env ]; then
  exit 0
fi

echo "Creating .env file..."
echo "Press Enter to use default values shown in brackets"
echo ""

read -p "Environment name (e.g., your initials) [dev]: " ENV
ENV=${ENV:-dev}
read -p "Datadog API Key: " DD_API_KEY
read -p "Datadog Site [datadoghq.eu]: " DD_SITE
DD_SITE=${DD_SITE:-datadoghq.eu}
read -p "Datadog RUM Application ID [default-rum-app-id]: " DD_RUM_APPLICATION_ID
DD_RUM_APPLICATION_ID=${DD_RUM_APPLICATION_ID:-default-rum-app-id}
read -p "Datadog RUM Client Token [default-rum-client-token]: " DD_RUM_CLIENT_TOKEN
DD_RUM_CLIENT_TOKEN=${DD_RUM_CLIENT_TOKEN:-default-rum-client-token}
read -p "Commit SHA [latest]: " COMMIT_SHA
COMMIT_SHA=${COMMIT_SHA:-latest}

if [ -n "$CODESPACE_NAME" ]; then
  DEPLOYMENT_HOST_URL="https://${CODESPACE_NAME}-8080.app.github.dev"
else
  DEPLOYMENT_HOST_URL="http://localhost:8080"
fi

cat > .env << EOF
# Deployment Configuration
ENV=$ENV
COMMIT_SHA=$COMMIT_SHA
DEPLOYMENT_HOST_URL=$DEPLOYMENT_HOST_URL

# Datadog Configuration
DD_API_KEY=$DD_API_KEY
DD_SITE=$DD_SITE
DD_RUM_APPLICATION_ID=$DD_RUM_APPLICATION_ID
DD_RUM_CLIENT_TOKEN=$DD_RUM_CLIENT_TOKEN
EOF

echo ""
echo ".env file created successfully!"
"""

# =============================================================================
# build: Build tasks
# =============================================================================

[tasks."build:local"]
description = "Build all services locally"
run = "mise run '//...:build:local'"

[tasks."build:docker-dev"]
description = "Build all dev containers"
run = "mise run '//...:build:docker-dev'"

[tasks."build:docker-release"]
description = "Build all release containers"
run = "mise run '//...:build:docker-release'"

# =============================================================================
# infra: Infrastructure setup tasks
# =============================================================================

[tasks."infra:install"]
description = "Install all CDK dependencies"
run = "mise run '//...:infra:install'"

# =============================================================================
# compose: Docker Compose tasks
# =============================================================================

[tasks."compose:deploy:local"]
description = "Deploy all services locally (build from source)"
depends = ["env:setup"]
run = "docker compose --profile monitoring build && docker compose --profile monitoring up -d"

[tasks."compose:deploy:release"]
description = "Deploy all services using prebuilt GHCR images"
depends = ["env:setup"]
run = "docker compose --profile monitoring -f docker-compose.yml -f docker-compose.prebuilt.yml up -d"

[tasks."compose:deploy:ci"]
description = "Deploy services for CI (no monitoring)"
depends = ["env:setup"]
run = "docker compose build && docker compose up -d"

[tasks."compose:dev"]
description = "Deploy all services with hot reload"
depends = ["env:setup"]
run = "docker compose --profile monitoring -f docker-compose.yml -f docker-compose.dev.yml build && docker compose --profile monitoring -f docker-compose.yml -f docker-compose.dev.yml up -d"

[tasks."compose:down"]
description = "Stop and remove all containers and volumes"
run = "docker compose --profile monitoring down -v"

# =============================================================================
# test: Testing tasks
# =============================================================================

[tasks."test:wait"]
description = "Wait for all services to be healthy"
depends = ["env:setup"]
run = "./scripts/wait-for-services.sh"

[tasks."test:services"]
description = "Test that all services are responding"
depends = ["env:setup"]
run = "./scripts/test-services.sh --max-retries 5 --retry-delay 10"

# =============================================================================
# aws: AWS deployment tasks
#
# Deployment modes are controlled via the DEPLOY_MODE environment variable:
#   - local:   Build containers from local Dockerfiles (DEPLOY_MODE=local)
#   - release: Pull prebuilt images from GHCR tagged "latest" (DEPLOY_MODE=release)
#   - (unset): Falls back to COMMIT_SHA env var, or "latest" if not set
#
# DEPLOY_MODE is NOT stored in .env, so it propagates naturally through
# subprocess calls. CDK's SharedProps reads DEPLOY_MODE and sets the
# appropriate image tag. Services can define their own aws:deploy:local
# and aws:deploy:release tasks that set DEPLOY_MODE and delegate to aws:deploy.
#
# To deploy a specific tagged version from the registry (e.g., a CI-built
# image), set COMMIT_SHA to the desired tag and run aws:deploy directly
# without setting DEPLOY_MODE. For example:
#   COMMIT_SHA=abc123 npx cdk deploy (from infra/aws directory)
# =============================================================================

[tasks."aws:deploy:local"]
description = "Deploy to AWS (build containers locally)"
depends = ["env:setup"]
env = { DEPLOY_MODE = "local" }
run = """
echo "=== Deploying Stickerlandia to AWS: $ENV (DEPLOY_MODE=$DEPLOY_MODE) ==="
mise run //shared:aws:deploy
mise run //user-management:aws:deploy
mise run //sticker-award:aws:deploy
mise run //sticker-catalogue:aws:deploy
mise run //web-backend:aws:deploy
mise run //web-frontend:aws:deploy
echo "=== Deployment complete! ==="
"""

[tasks."aws:deploy:release"]
description = "Deploy to AWS using prebuilt GHCR images"
depends = ["env:setup"]
env = { DEPLOY_MODE = "release" }
run = """
echo "=== Deploying Stickerlandia to AWS: $ENV (DEPLOY_MODE=$DEPLOY_MODE) ==="
mise run //shared:aws:deploy
mise run //user-management:aws:deploy
mise run //sticker-award:aws:deploy
mise run //sticker-catalogue:aws:deploy
mise run //web-backend:aws:deploy
mise run //web-frontend:aws:deploy
echo "=== Deployment complete! ==="
"""

[tasks."aws:down"]
description = "Destroy all AWS stacks"
depends = ["//shared:aws:down"]
run = """
echo '=== Cleaning up CDK context cache ==='
find . -name 'cdk.context.json' -type f -delete
echo '=== All AWS stacks destroyed! ==='
"""

[tasks."aws:info"]
description = "Show AWS stack outputs for all services"
run = """
mise run //shared:aws:info
mise run //user-management:aws:info
mise run //sticker-award:aws:info
mise run //sticker-catalogue:aws:info
mise run //web-backend:aws:info
mise run //web-frontend:aws:info
"""

# =============================================================================
# ui-test: UI Testing infrastructure
# =============================================================================

[tasks."ui-test:install"]
description = "Install UI test dependencies and Playwright browsers"
dir = "e2e"
sources = ["package-lock.json"]
outputs = ["node_modules/.package-lock.json"]
run = "npm ci && npx playwright install --with-deps chromium"

[tasks."ui-test:codegen"]
description = "Record tests with Playwright codegen"
dir = "e2e"
depends = ["ui-test:install", "env:setup"]
run = "npx playwright codegen ${DEPLOYMENT_HOST_URL:-http://localhost:8080}"

# =============================================================================
# compose: UI test tasks for Docker Compose deployment
# =============================================================================

[tasks."compose:ui-test"]
description = "Run UI tests against Docker Compose deployment"
dir = "e2e"
depends = ["ui-test:install", "env:setup"]
env = { BASE_URL = "http://localhost:8080" }
run = "npx playwright test"

[tasks."compose:ui-test:ui"]
description = "Open Playwright UI mode for Docker Compose deployment"
dir = "e2e"
depends = ["ui-test:install", "env:setup"]
env = { BASE_URL = "http://localhost:8080" }
run = "npx playwright test --ui"

# =============================================================================
# aws: UI test tasks for AWS deployment
# =============================================================================

[tasks."aws:ui-test"]
description = "Run UI tests against AWS deployment"
dir = "e2e"
depends = ["ui-test:install"]
run = """
BASE_URL=$(aws cloudformation describe-stacks \
  --stack-name "StickerlandiaSharedResources-${ENV:-dev}" \
  --query "Stacks[0].Outputs[?OutputKey=='BaseUrl'].OutputValue" \
  --output text)
echo "Running tests against: $BASE_URL"
BASE_URL=$BASE_URL npx playwright test
"""

# =============================================================================
# load: Load testing tasks
# =============================================================================

[tasks."load:smoke"]
depends = ["env:setup"]
description = "Run smoke load test (2 users, 30 seconds, mixed flows)"
run = """
docker compose --profile load-test up -d
docker compose --profile load-test run --rm load-simulator
docker compose --profile load-test down -v
"""

[tasks."load:smoke:public"]
depends = ["env:setup"]
description = "Run smoke test on public endpoints only"
run = """
docker compose --profile load-test up -d
docker compose --profile load-test run --rm -e SCENARIO=public load-simulator
docker compose --profile load-test down -v
"""

[tasks."load:smoke:auth"]
depends = ["env:setup"]
description = "Run smoke test on authenticated flows only"
run = """
docker compose --profile load-test up -d
docker compose --profile load-test run --rm -e SCENARIO=auth load-simulator
docker compose --profile load-test down -v
"""

[tasks."load:test"]
depends = ["env:setup"]
description = "Run load test (ramp to 30 users over 10 minutes)"
run = """
docker compose --profile load-test up -d
docker compose --profile load-test run --rm -e WORKLOAD=load load-simulator
docker compose --profile load-test down -v
"""

[tasks."load:test:auth"]
depends = ["env:setup"]
description = "Run load test on authenticated flows only"
run = """
docker compose --profile load-test up -d
docker compose --profile load-test run --rm -e WORKLOAD=load -e SCENARIO=auth load-simulator
docker compose --profile load-test down -v
"""

[tasks."load:smoke:register"]
depends = ["env:setup"]
description = "Run smoke test on registration flow"
run = """
docker compose --profile load-test up -d
docker compose --profile load-test run --rm -e SCENARIO=register load-simulator
docker compose --profile load-test down -v
"""

[tasks."load:start"]
depends = ["env:setup"]
description = "Start load test services (use with load:sustained:run and load:stop)"
run = """
docker compose --profile load-test up -d --wait
"""

[tasks."load:stop"]
description = "Stop load test services and clean up volumes"
run = """
docker compose --profile load-test down -v
"""

[tasks."load:provision-users"]
depends = ["env:setup"]
description = "Register test users from pool (run once before multi-user auth tests)"
run = """
docker compose --profile load-test up -d --wait
docker compose --profile load-test run --rm load-simulator run /scripts/provision-users.js
echo "Users provisioned. Services still running - run 'mise run load:sustained:run' or 'mise run load:stop' when done."
"""

[tasks."load:sustained"]
depends = ["env:setup"]
description = "Run sustained load test (full cycle: start, provision users, test, stop)"
run = """
docker compose --profile load-test up -d --wait
echo "Provisioning test users..."
docker compose --profile load-test run --rm load-simulator run /scripts/provision-users.js
echo "Running sustained load test..."
docker compose --profile load-test run --rm -e WORKLOAD=${WORKLOAD:-sustained} load-simulator
docker compose --profile load-test down -v
"""

[tasks."load:sustained:run"]
depends = ["env:setup"]
description = "Run sustained load test only (assumes services already running with provisioned users)"
run = """
docker compose --profile load-test run --rm -e WORKLOAD=${WORKLOAD:-sustained} load-simulator
"""

